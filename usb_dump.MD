Результат дампа:
```
ffff90e320da7b40 319503474 S Ci:3:010:0 s 80 06 0300 0000 0004 4 <
ffff90e320da7b40 319503634 C Ci:3:010:0 0 4 = 04030904
ffff90e320da7c00 319503693 S Ci:3:010:0 s 80 06 0303 0409 00ff 255 <
ffff90e320da7c00 319503865 C Ci:3:010:0 0 26 = 1a033000 30003000 30003000 30003000 30003000 30003000 3100
ffff90e320da7c00 319503894 S Ci:3:010:0 s 80 06 0300 0000 0004 4 <
ffff90e320da7c00 319503984 C Ci:3:010:0 0 4 = 04030904
ffff90e320da7b40 319504031 S Ci:3:010:0 s 80 06 0302 0409 00ff 255 <
ffff90e320da7b40 319504213 C Ci:3:010:0 0 56 = 38034600 54004400 49002000 53007500 70006500 72005300 70006500 65006400
ffff90e320da73c0 319505204 S Ci:3:010:0 s c0 f1 0000 0000 0004 4 <
ffff90e320da73c0 319505385 C Ci:3:010:0 0 4 = 09010000
ffff90e320da73c0 319505544 S Ci:3:010:0 s c0 03 0001 8400 0004 4 <
ffff90e320da73c0 319505706 C Ci:3:010:0 0 4 = 00001702
ffff90e320da7b40 319505907 S Ci:3:010:0 s c0 03 0001 8000 0004 4 <
ffff90e320da7b40 319506048 C Ci:3:010:0 0 4 = 000a2301
ffff90e28c1386c0 319506209 S Ci:3:010:0 s c0 cf 0001 0000 0098 152 <
ffff90e28c1386c0 319506444 C Ci:3:010:0 0 152 = 03041f60 0a034600 54004400 49003803 46005400 44004900 20005300 75007000
ffff90e320da7c00 319506529 S Ii:3:010:1 -115:256 12 <
ffff90e320da7b40 319506683 S Bo:3:010:1 -115 20 = 00000000 82030000 00000000 00000000 00000000
ffff90e320da7b40 319506709 C Bo:3:010:1 0 20 >
ffff90e320da73c0 319506819 S Bo:3:010:1 -115 20 = 00000000 82000000 00000000 00000000 00000000
ffff90e320da73c0 319506846 C Bo:3:010:1 0 20 >
ffff90e320da73c0 319506874 S Bo:3:010:1 -115 20 = 00000000 82020000 20000000 00000000 00000000
ffff90e320da73c0 319506893 C Bo:3:010:1 0 20 >
ffff90e320da7b40 319506938 S Bo:3:010:2 -115 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da7b40 319506964 C Bo:3:010:2 0 32 >
ffff90e320da7b40 319607290 S Bi:3:010:2 -115 32 <
ffff90e320da7b40 319607436 C Bi:3:010:2 0 0
ffff90e320da73c0 320607870 S Bo:3:010:2 -115 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da73c0 320608000 C Bo:3:010:2 0 32 >
ffff90e320da73c0 320708454 S Bi:3:010:2 -115 32 <
ffff90e320da73c0 320708564 C Bi:3:010:2 0 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da7b40 321709002 S Bo:3:010:2 -115 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da7b40 321709110 C Bo:3:010:2 0 32 >
ffff90e320da7b40 321809563 S Bi:3:010:2 -115 32 <
ffff90e320da7b40 321809677 C Bi:3:010:2 0 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da73c0 322810134 S Bo:3:010:2 -115 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da73c0 322810241 C Bo:3:010:2 0 32 >
ffff90e320da73c0 322910695 S Bi:3:010:2 -115 32 <
ffff90e320da73c0 322910809 C Bi:3:010:2 0 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da7b40 323911260 S Bo:3:010:2 -115 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da7b40 323911364 C Bo:3:010:2 0 32 >
ffff90e320da7b40 324011805 S Bi:3:010:2 -115 32 <
ffff90e320da7b40 324011918 C Bi:3:010:2 0 32 = 00010203 04050607 08090a0b 0c0d0e0f 10111213 14151617 18191a1b 1c1d1e1f
ffff90e320da7c00 324360887 C Ii:3:010:1 -108:256 0
```

Анализ:

Наблюдается вполне типичная для USB-трафика на FT601 (или похожем USB‐FIFO) картина:

1. **Сначала идут стандартные запросы к устройству** на получение дескрипторов (String Descriptor и т.п.):

   ```
   S Ci:3:010:0 s 80 06 0300 ...
   C Ci:3:010:0 0 4  = 04030904
   ...
   S Ci:3:010:0 s 80 06 0303 ...
   ...
   ```

   - `80 06` — это стандартный GET_DESCRIPTOR (Direction=IN, Type=Standard, Recipient=Device).
   - Параметры `0300`, `0302`, `0303` и т.д. указывают, что запрашиваются String Descriptors с разными индексами (0, 2, 3).  
   - Ответы типа `04030904`, `1a033000 30003000 ...` — это возвращаемые Unicode-строки (включая LangID 0x0409, iProduct, iManufacturer, iSerialNumber).

2. **Далее видно несколько вендерных (vendor‐specific) запросов** (bRequest = 0xf1, 0x03, 0xcf и т.п.):

   ```
   S Ci:3:010:0 s c0 f1 0000 0000 ...
   C Ci:3:010:0 0 4 = 09010000

   S Ci:3:010:0 s c0 03 0001 8400 ...
   C Ci:3:010:0 0 4 = 00001702
   ...
   S Ci:3:010:0 s c0 03 0001 8000 ...
   C Ci:3:010:0 0 4 = 000a2301

   S Ci:3:010:0 s c0 cf 0001 0000 0098 ...
   C Ci:3:010:0 0 152 = 03041f60 0a034600 ...
   ...
   ```
   Это внутренние (проприетарные) команды FTDI/FT601 для конфигурации режима FIFO, управления питанием, чтения/записи регистров и т.п. Они не описаны стандартом USB, поэтому видны как “s c0 … bRequest = …”.

3. **Основной обмен данными** проходит по BULK (bulk) эндпоинтам:
   - `Bo:3:010:1` — **Bulk OUT** на интерфейсе №0 (Endpoint 1 OUT).
   - `Bi:3:010:1` или `Ii:3:010:1` — в некоторых случаях может быть Interrupt IN (но у FT601 первый интерфейс действительно обычно имеет EP 1 OUT как bulk и EP 1 IN как interrupt, см. bEndpointAddress=0x81).  
   - Однако основные данные (особенно «широкий» FIFO) обычно идут через **Endpoint 2** IN/OUT (0x02/0x82) на **Interface 1**.

   По логу видно:
   ```
   S Bo:3:010:2 -115 32 = 00010203 04050607 ...
   C Bo:3:010:2 0 32 >
   ...
   S Bi:3:010:2 -115 32 <
   C Bi:3:010:2 0 0
   ```
   — Вы отправляете 32 байта (0x00..0x1F) на Endpoint 2 OUT, а сразу в ответ первый раз чтение даёт 0 (то есть устройство пока ничего не выдало).  

   Потом:
   ```
   S Bo:3:010:2 -115 32 = 00010203 04050607 ...
   C Bo:3:010:2 0 32 >
   S Bi:3:010:2 -115 32 <
   C Bi:3:010:2 0 32 = 00010203 04050607 ... 1c1d1e1f
   ```
   — Теперь при повторном чтении приходит ровно те же 32 байта `0x00..0x1F`. То есть видно, что устройство «отдаёт» обратно те же данные, которые были отправлены (либо потому что на аппаратном уровне подключена какая-то петля, либо прошивка/драйвер сам их эхо-лупит, либо это стандартный тест FIFO).

   Далее эти циклы «записал 32 байта — прочитал 32 байта» повторяются:
   ```
   ...
   319506938 S Bo:3:010:2 -115 32 = 00010203 ...
   319506964 C Bo:3:010:2 0 32 >
   319607290 S Bi:3:010:2 -115 32 <
   319607436 C Bi:3:010:2 0 0
   ...
   320607870 S Bo:3:010:2 -115 32 ...
   320608000 C Bo:3:010:2 0 32 >
   320708454 S Bi:3:010:2 -115 32 <
   320708564 C Bi:3:010:2 0 32 = 00010203 ...
   ...
   ```
   Каждые ~1 секунду или сколько-то там (судя по номерам пакетов/таймштампам) снова идёт пара: **запись 32 байт** и **чтение**. Иногда **в первом чтении** сразу после записи приходит `0` (то есть устройство ещё ничего не вернуло), а **во втором чтении** — уже возвращаются эти же 32 байта.

4. **Итог**:
   - Первая часть лога — это **стандартная USB-инициализация** (дескрипторы) + **несколько вендерных Control Transfer** для настройки чипа.
   - Вторая часть лога — это **повторяющиеся тестовые передачи** по **Bulk Endpoint 2** (OUT и IN) в блоках по 32 байта (0x00..0x1F).  
   - Судя по всему, устройство либо аппаратно «зализывает» (эмулирует петлю), либо используется какой-то тестовый режим, где то, что посылается на OUT, потом можно считать обратно тем же самым по IN.  

Это стандартная ситуация при работе с FT601: вы видите, как драйвер (или ваша собственная программа) «запихивает» 32 байта в FIFO (через USB Bulk OUT) и потом эти же 32 байта вычитывает из FIFO (Bulk IN). При этом иногда первое чтение после записи возвращает 0 (буфер пуст), а при повторном запросе устройство уже «выдаёт» данные. Всё остальное (vendor-specific control requests) — это внутренние регистры и настройки FTDI.

# ВОПРОС: "При непосредственно передаче шестнадцатеричных чисел от 0x00 до 0x1f передается ли какой-либо "мусор"?"

Если смотреть **на сами полезные данные** (payload), которые уходят и приходят по Bulk Endpoint’у (конкретно строки вида `S Bo:3:010:2 -115 32 = 00010203 ...` и `C Bi:3:010:2 0 32 = 00010203 ...`), то **никакого дополнительного «мусора»** в передаваемом блоке нет: устройство действительно получает ровно те 32 байта от 0x00 до 0x1F и отдает те же 32 байта.

Другое дело, что:

1. **На уровне USB-протокола** всегда есть служебные пакеты и байты (Token, Handshake, CRC, пр.). Они неизбежны, но «невидимы» для прикладного уровня. То есть на шине USB физически уходят дополнительные пакеты заголовков и подтверждений, но в usbmon-дампе указываются только параметры и собственно «полезная нагрузка» (data), а не весь сырый битстрим.

2. **В usbmon-трассе** мы видим и «лишние» (для основной задачи) запросы типа GET_DESCRIPTOR, vendor-specific control transfer и т.п. Но это не то же самое, что «мусор» в самих данных. Это просто служебные или инициализационные пакеты, которые происходят при работе драйвера/ядра с устройством и выводятся в тот же лог.

В итоге, если вопрос в том, «не подкладывает ли устройство или драйвер ещё какие-то байты вместе с (0x00..0x1F)», то **внутри самих 32-байтовых посылок посторонних данных нет**. Всё передаётся ровно тем блоком, который вы видите в дампе: `00010203 … 1c1d1e1f`.

# ВОПРОС: "а как перехватить этот "мусор"?"

Если под «мусором» вы имеете в виду **самые низкоуровневые USB-пакеты** (Token Packet, Handshake Packet, CRC и пр.), то есть те байты и поля, которые контроллер USB «сам» формирует и обрабатывает на аппаратном уровне, то:

1. **Стандартные системные инструменты (usbmon, Wireshark с USBPCap и т.п.)** позволяют перехватывать только **уровень контроллера** (Host Controller Interface, HCI) и выше. То есть вы видите уже «логические» транзакции, где USB-аппаратная часть обрезает стартовые/заголовочные байты и проверяет контрольные суммы за вас.  
   - В usbmon, к примеру, каждая запись показывает параметры запроса (Setup Packet для Control Transfers) и только **полезную нагрузку** (Payload) для Bulk/Interrupt/Control.  
   - «Мусор» на уровне битов (маркер пакета, CRC5, CRC16, PID и т.п.) уже не захватывается и в дампе не фигурирует.

2. Если вам нужно **увидеть именно сырые физические пакеты** (PID токена `OUT/IN`, Handshake `ACK/NAK`, поля CRC, номера кадров), то здесь, как правило, нужна **аппаратная USB-протокол-анализатор** (hardware USB protocol analyzer). Это отдельное устройство, которое включается в разрыв USB-линии или применяется вместо обычного кабеля и «подслушивает» полную физическую передачу, не пропуская никакие биты.

3. **Некоторые специализированные решения** (например, от Total Phase, LeCroy/Teledyne, Ellisys, Beagle и т.п.) дают возможность видеть весь поток на уровне USB 2.0/3.0 протокола с низкоуровневыми деталями. Но эти анализаторы довольно дорогие и ориентированы на разработчиков железа/микропрограмм.

Таким образом, **программные инструменты (usbmon и т. д.) показывают только верхний уровень** (пакеты данных и метаданные транзакций), а **полностью «сырые» фреймы с «мусором» (CRC, PID)** можно увидеть, если использовать **аппаратный USB Protocol Analyzer**.
